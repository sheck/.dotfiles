#!/usr/bin/env ruby

require 'optparse'
require 'tempfile'

# Check required dependencies
def check_dependencies
  dependencies = {
    'gum' => 'https://github.com/charmbracelet/gum',
    'bat' => 'https://github.com/sharkdp/bat',
    'llm' => 'https://llm.datasette.io/'
  }

  dependencies.each do |cmd, url|
    unless system("command -v #{cmd} > /dev/null 2>&1")
      puts "Error: #{cmd} is not installed. Install it from #{url}"
      exit 1
    end
  end
end

# Parse command line arguments
def parse_arguments
  options = {
    context: false,
    claude: false,
    summary_only: false
  }

  OptionParser.new do |opts|
    opts.on('-c', '--context', 'Prompt for context') { options[:context] = true }
    opts.on('--claude', 'Get context from Claude') { options[:claude] = true }
    opts.on('-s', '--summary-only', 'Summary only') { options[:summary_only] = true }
  end.parse!

  options
end

# Clean blank lines and remove markdown fences
def clean_blank_lines(input_file)
  output = Tempfile.new('cleaned')

  content = File.read(input_file)
  # Remove markdown code fences
  content = content.gsub(/^```$/, '')

  # Remove leading blank lines and consecutive blank lines
  lines = content.lines
  result = []
  blank_found = false
  started = false

  lines.each do |line|
    if line.strip.empty?
      if started && !blank_found
        result << line
        blank_found = true
      end
    else
      result << line
      blank_found = false
      started = true
    end
  end

  output.write(result.join)
  output.close
  output.path
end

# Add LLM disclaimer after first line
def add_disclaimer(input_file, summary_only = false)
  output = Tempfile.new('disclaimer')

  lines = File.readlines(input_file)
  summary = lines[0]

  output.puts summary.chomp
  output.puts ""
  output.puts "This commit message was generated with the help of LLMs."

  unless summary_only
    lines[1..-1].each { |line| output.write(line) }
  end

  output.close
  output.path
end

# Main function
def main
  check_dependencies
  options = parse_arguments

  # Get the git diff
  diff = `git diff --cached`

  if diff.strip.empty?
    puts "No staged changes to commit"
    exit 1
  end

  # Collect context if -c flag is provided
  context = ""
  if options[:context]
    context = `gum write --placeholder "What motivated this change? Is there context a future reader will need to know? What problem did you solve?"`.chomp
  end

  # Collect context from Claude if --claude flag is provided
  if options[:claude]
    claude_context = `claude --continue --print "What context from this session would be useful for writing a commit message? Don't suggest a message or list affected files. Focus on the WHY of this work."`.chomp
    if !context.empty?
      context = "#{context}\n#{claude_context}"
    else
      context = claude_context
    end
  end

  # Start with default temperature
  temp_options = []
  reroll_count = 0
  base_prompt = <<~PROMPT
    Write a git commit message for these changes. Format it as:
    - First line: a summary of 72 characters or less
    - Second line: blank
    - Remaining lines: detailed description (keep this BRIEF - 2-4 sentences max)
    The tone should be confident, conversational, and slightly irreverent, mixing technical precision with plainspoken candor. Write as an experienced expert speaking peer-to-peer, empathetic to pain points but authoritative in solutions. Keep it credible, no-nonsense, and built for engineers tired of vague marketing.
    Be concise. Every word should earn its place.
    Return only the commit message.
  PROMPT

  if !context.empty?
    prompt = "#{base_prompt}\nAdditional context from the developer:\n#{context}"
  else
    prompt = base_prompt
  end

  # Loop to allow rerolls
  loop do
    # Generate commit message and save to temp file
    temp_file = Tempfile.new('commit')

    IO.popen("llm -s \"#{prompt}\" #{temp_options.join(' ')}", 'w+') do |io|
      io.write(diff)
      io.close_write
      temp_file.write(io.read)
    end

    temp_file.close

    # Read first line to check length
    summary = File.readlines(temp_file.path)[0].chomp
    summary_length = summary.length

    if summary_length > 72
      puts "Summary too long (#{summary_length} chars), regenerating..."
      temp_file.unlink
      next
    end

    # Clean up blank lines
    cleaned_file = clean_blank_lines(temp_file.path)
    temp_file.unlink
    temp_file_path = cleaned_file

    # Add disclaimer for display and commit
    display_file = add_disclaimer(temp_file_path, options[:summary_only])

    # Show the generated message
    puts "Generated commit message:"
    system("bat -P -H 1 --style=changes,grid,numbers,snip #{display_file}")

    # Let user choose what to do
    action = `gum choose "Commit" "Commit and Push" "Edit" "Reroll" "Condense" "Cancel"`.chomp

    case action
    when "Commit"
      system("git commit -F #{display_file}")
      File.unlink(temp_file_path)
      File.unlink(display_file)
      exit 0
    when "Commit and Push"
      system("git commit -F #{display_file}")
      File.unlink(temp_file_path)
      File.unlink(display_file)
      system("git push")
      exit 0
    when "Edit"
      editor = ENV['EDITOR'] || 'vim'
      system("#{editor} #{display_file}")
      system("git commit -F #{display_file}")
      File.unlink(temp_file_path)
      File.unlink(display_file)
      exit 0
    when "Reroll"
      reroll_count += 1
      temp = 0.5 + reroll_count * 0.3
      temp_options = ["-o", "temperature", temp.to_s]
      puts "Generating new message (temperature: #{temp})..."
      File.unlink(temp_file_path)
      File.unlink(display_file)
      next
    when "Condense"
      puts "Condensing message..."
      current_message = File.read(temp_file_path)
      condense_prompt = "Take this commit message and make it more concise while retaining the what and the why:\n#{current_message}"

      condensed_file = Tempfile.new('condensed')
      IO.popen("llm", 'w+') do |io|
        io.write(condense_prompt)
        io.close_write
        condensed_file.write(io.read)
      end
      condensed_file.close

      File.unlink(temp_file_path)
      temp_file_path = condensed_file.path

      # Clean up blank lines after condensing
      cleaned_file = clean_blank_lines(temp_file_path)
      File.unlink(temp_file_path)
      temp_file_path = cleaned_file

      File.unlink(display_file)
      next
    when "Cancel"
      puts "Commit cancelled"
      File.unlink(temp_file_path)
      File.unlink(display_file)
      exit 1
    end
  end
end

# Run the main function
main
